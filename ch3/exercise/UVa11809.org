* UVa11809 - Floating-Point Numbers
原题链接为：[[https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=830&problem=2909&mosmsg=Submission+received+with+ID+22045111][Floating-Point Numbers]]。
大意为：对于给定的输入：AeB的形式，是一个十进制的浮点数，大小为A * 10^{B}，输入保证这个浮点数的二进制表示全都为1，求这个二进制数的尾数M和阶码E。
** 浮点数的表示知识点
浮点数的表示形式为：0.X\times2^{Y}

其中，X和Y都是二进制的表示，而且，像科学计数法规定小数点前只包含一个个位数，这个二进制表示也强制规定小数点后第一位必须为1。

基于上面的规定，X将用M位尾码来表示，Y由E位阶码来表示。需要注意的是，由于小数点后第一位固定为1，为了节省空间（或者使得表现力更强），第一位便省略不写，故用来表示X实际上是由M+1位二进制数字。
举个例子：
0.111111111_{2} \times 2^{111111_{2}}
= 0.998046875 \times 2^{63}
= 9.205357638345294 \times 10^{18}

浮点数能够表达很大的数，最根本的原因就在与阶码的表示，一个32位的整数，最大只能表达2^32-1的数，而对于浮点数，只需要6位阶码，就能表示X\times 2^{63}的数，X可以很接近1，可见，再多几位阶码，自然能够表达更大的数。

** 问题分析
看准输入和输出很重要。
原题中，指名了输入保证唯一解，而且保证0\leq M\leq 9，1\leq E\leq 30。数据如此之小，基本就在暗示打表了。

当然，此题的难点也就在这里显现了出来，如果说要计算这些M和E表示的数，是很容易溢出的（数字可达2^{2^{30}-1}，C++中double也仅有11位的阶码，而这里却可达30）。

于是，我自己在这里卡了很久，最后还是查了题解，不得不说，数学水平真的下降得太多了，基本的转化方法都想不起来，看来真的是需要多练习啊。
问题实际上是这样的：

给定了A\times 10^B这样的字串表示，要找到0.X\times2^Y与之相等，若是在以前，估计应该很快就能想到了吧，两边取对数即可，而现在，有点物是人非了。。。
取对数（以10为底，lg）

故就是要找到lg(A) + B == lg(0.X) + Ylg(2)，这里注意X和Y分别由M和E求得，然后通过计算lg的值进行打表，然后对输入的值进行遍历查询即可。

** 代码中不熟悉的地方
这个输入是AeB，题目保证A有15位小数，前两位为个位和小数点，因此需要对输入进行一点点的处理。
这里用到了几个函数：
*** char *strcnpy(char *dst, char *src, size_t len)
因为知道A的长度，故截取前面17位即可。但是需要注意的是，如果src长度度大于len时，dst末尾没有NUL，需要自己手动给最后一位赋0。

*** double atof(const char *str)
字符数组转化为浮点数，当然类似的还有atoi()

*** char *strcpy(char *dst, char *src)
后面的B的长度是不定的，故需要用到这个函数


